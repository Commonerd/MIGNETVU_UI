/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/leaflet-polylinedecorator";
exports.ids = ["vendor-chunks/leaflet-polylinedecorator"];
exports.modules = {

/***/ "(ssr)/./node_modules/leaflet-polylinedecorator/dist/leaflet.polylineDecorator.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/leaflet-polylinedecorator/dist/leaflet.polylineDecorator.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval("(function (global, factory) {\n\t true ? factory(__webpack_require__(/*! leaflet */ \"(ssr)/./node_modules/leaflet/dist/leaflet-src.js\")) :\n\t0;\n}(this, (function (L$1) { 'use strict';\n\nL$1 = L$1 && L$1.hasOwnProperty('default') ? L$1['default'] : L$1;\n\n// functional re-impl of L.Point.distanceTo,\n// with no dependency on Leaflet for easier testing\nfunction pointDistance(ptA, ptB) {\n    var x = ptB.x - ptA.x;\n    var y = ptB.y - ptA.y;\n    return Math.sqrt(x * x + y * y);\n}\n\nvar computeSegmentHeading = function computeSegmentHeading(a, b) {\n    return (Math.atan2(b.y - a.y, b.x - a.x) * 180 / Math.PI + 90 + 360) % 360;\n};\n\nvar asRatioToPathLength = function asRatioToPathLength(_ref, totalPathLength) {\n    var value = _ref.value,\n        isInPixels = _ref.isInPixels;\n    return isInPixels ? value / totalPathLength : value;\n};\n\nfunction parseRelativeOrAbsoluteValue(value) {\n    if (typeof value === 'string' && value.indexOf('%') !== -1) {\n        return {\n            value: parseFloat(value) / 100,\n            isInPixels: false\n        };\n    }\n    var parsedValue = value ? parseFloat(value) : 0;\n    return {\n        value: parsedValue,\n        isInPixels: parsedValue > 0\n    };\n}\n\nvar pointsEqual = function pointsEqual(a, b) {\n    return a.x === b.x && a.y === b.y;\n};\n\nfunction pointsToSegments(pts) {\n    return pts.reduce(function (segments, b, idx, points) {\n        // this test skips same adjacent points\n        if (idx > 0 && !pointsEqual(b, points[idx - 1])) {\n            var a = points[idx - 1];\n            var distA = segments.length > 0 ? segments[segments.length - 1].distB : 0;\n            var distAB = pointDistance(a, b);\n            segments.push({\n                a: a,\n                b: b,\n                distA: distA,\n                distB: distA + distAB,\n                heading: computeSegmentHeading(a, b)\n            });\n        }\n        return segments;\n    }, []);\n}\n\nfunction projectPatternOnPointPath(pts, pattern) {\n    // 1. split the path into segment infos\n    var segments = pointsToSegments(pts);\n    var nbSegments = segments.length;\n    if (nbSegments === 0) {\n        return [];\n    }\n\n    var totalPathLength = segments[nbSegments - 1].distB;\n\n    var offset = asRatioToPathLength(pattern.offset, totalPathLength);\n    var endOffset = asRatioToPathLength(pattern.endOffset, totalPathLength);\n    var repeat = asRatioToPathLength(pattern.repeat, totalPathLength);\n\n    var repeatIntervalPixels = totalPathLength * repeat;\n    var startOffsetPixels = offset > 0 ? totalPathLength * offset : 0;\n    var endOffsetPixels = endOffset > 0 ? totalPathLength * endOffset : 0;\n\n    // 2. generate the positions of the pattern as offsets from the path start\n    var positionOffsets = [];\n    var positionOffset = startOffsetPixels;\n    do {\n        positionOffsets.push(positionOffset);\n        positionOffset += repeatIntervalPixels;\n    } while (repeatIntervalPixels > 0 && positionOffset < totalPathLength - endOffsetPixels);\n\n    // 3. projects offsets to segments\n    var segmentIndex = 0;\n    var segment = segments[0];\n    return positionOffsets.map(function (positionOffset) {\n        // find the segment matching the offset,\n        // starting from the previous one as offsets are ordered\n        while (positionOffset > segment.distB && segmentIndex < nbSegments - 1) {\n            segmentIndex++;\n            segment = segments[segmentIndex];\n        }\n\n        var segmentRatio = (positionOffset - segment.distA) / (segment.distB - segment.distA);\n        return {\n            pt: interpolateBetweenPoints(segment.a, segment.b, segmentRatio),\n            heading: segment.heading\n        };\n    });\n}\n\n/**\n* Finds the point which lies on the segment defined by points A and B,\n* at the given ratio of the distance from A to B, by linear interpolation.\n*/\nfunction interpolateBetweenPoints(ptA, ptB, ratio) {\n    if (ptB.x !== ptA.x) {\n        return {\n            x: ptA.x + ratio * (ptB.x - ptA.x),\n            y: ptA.y + ratio * (ptB.y - ptA.y)\n        };\n    }\n    // special case where points lie on the same vertical axis\n    return {\n        x: ptA.x,\n        y: ptA.y + (ptB.y - ptA.y) * ratio\n    };\n}\n\n(function() {\r\n    // save these original methods before they are overwritten\r\n    var proto_initIcon = L.Marker.prototype._initIcon;\r\n    var proto_setPos = L.Marker.prototype._setPos;\r\n\r\n    var oldIE = (L.DomUtil.TRANSFORM === 'msTransform');\r\n\r\n    L.Marker.addInitHook(function () {\r\n        var iconOptions = this.options.icon && this.options.icon.options;\r\n        var iconAnchor = iconOptions && this.options.icon.options.iconAnchor;\r\n        if (iconAnchor) {\r\n            iconAnchor = (iconAnchor[0] + 'px ' + iconAnchor[1] + 'px');\r\n        }\r\n        this.options.rotationOrigin = this.options.rotationOrigin || iconAnchor || 'center bottom' ;\r\n        this.options.rotationAngle = this.options.rotationAngle || 0;\r\n\r\n        // Ensure marker keeps rotated during dragging\r\n        this.on('drag', function(e) { e.target._applyRotation(); });\r\n    });\r\n\r\n    L.Marker.include({\r\n        _initIcon: function() {\r\n            proto_initIcon.call(this);\r\n        },\r\n\r\n        _setPos: function (pos) {\r\n            proto_setPos.call(this, pos);\r\n            this._applyRotation();\r\n        },\r\n\r\n        _applyRotation: function () {\r\n            if(this.options.rotationAngle) {\r\n                this._icon.style[L.DomUtil.TRANSFORM+'Origin'] = this.options.rotationOrigin;\r\n\r\n                if(oldIE) {\r\n                    // for IE 9, use the 2D rotation\r\n                    this._icon.style[L.DomUtil.TRANSFORM] = 'rotate(' + this.options.rotationAngle + 'deg)';\r\n                } else {\r\n                    // for modern browsers, prefer the 3D accelerated version\r\n                    this._icon.style[L.DomUtil.TRANSFORM] += ' rotateZ(' + this.options.rotationAngle + 'deg)';\r\n                }\r\n            }\r\n        },\r\n\r\n        setRotationAngle: function(angle) {\r\n            this.options.rotationAngle = angle;\r\n            this.update();\r\n            return this;\r\n        },\r\n\r\n        setRotationOrigin: function(origin) {\r\n            this.options.rotationOrigin = origin;\r\n            this.update();\r\n            return this;\r\n        }\r\n    });\r\n})();\n\nL$1.Symbol = L$1.Symbol || {};\n\n/**\n* A simple dash symbol, drawn as a Polyline.\n* Can also be used for dots, if 'pixelSize' option is given the 0 value.\n*/\nL$1.Symbol.Dash = L$1.Class.extend({\n    options: {\n        pixelSize: 10,\n        pathOptions: {}\n    },\n\n    initialize: function initialize(options) {\n        L$1.Util.setOptions(this, options);\n        this.options.pathOptions.clickable = false;\n    },\n\n    buildSymbol: function buildSymbol(dirPoint, latLngs, map, index, total) {\n        var opts = this.options;\n        var d2r = Math.PI / 180;\n\n        // for a dot, nothing more to compute\n        if (opts.pixelSize <= 1) {\n            return L$1.polyline([dirPoint.latLng, dirPoint.latLng], opts.pathOptions);\n        }\n\n        var midPoint = map.project(dirPoint.latLng);\n        var angle = -(dirPoint.heading - 90) * d2r;\n        var a = L$1.point(midPoint.x + opts.pixelSize * Math.cos(angle + Math.PI) / 2, midPoint.y + opts.pixelSize * Math.sin(angle) / 2);\n        // compute second point by central symmetry to avoid unecessary cos/sin\n        var b = midPoint.add(midPoint.subtract(a));\n        return L$1.polyline([map.unproject(a), map.unproject(b)], opts.pathOptions);\n    }\n});\n\nL$1.Symbol.dash = function (options) {\n    return new L$1.Symbol.Dash(options);\n};\n\nL$1.Symbol.ArrowHead = L$1.Class.extend({\n    options: {\n        polygon: true,\n        pixelSize: 10,\n        headAngle: 60,\n        pathOptions: {\n            stroke: false,\n            weight: 2\n        }\n    },\n\n    initialize: function initialize(options) {\n        L$1.Util.setOptions(this, options);\n        this.options.pathOptions.clickable = false;\n    },\n\n    buildSymbol: function buildSymbol(dirPoint, latLngs, map, index, total) {\n        return this.options.polygon ? L$1.polygon(this._buildArrowPath(dirPoint, map), this.options.pathOptions) : L$1.polyline(this._buildArrowPath(dirPoint, map), this.options.pathOptions);\n    },\n\n    _buildArrowPath: function _buildArrowPath(dirPoint, map) {\n        var d2r = Math.PI / 180;\n        var tipPoint = map.project(dirPoint.latLng);\n        var direction = -(dirPoint.heading - 90) * d2r;\n        var radianArrowAngle = this.options.headAngle / 2 * d2r;\n\n        var headAngle1 = direction + radianArrowAngle;\n        var headAngle2 = direction - radianArrowAngle;\n        var arrowHead1 = L$1.point(tipPoint.x - this.options.pixelSize * Math.cos(headAngle1), tipPoint.y + this.options.pixelSize * Math.sin(headAngle1));\n        var arrowHead2 = L$1.point(tipPoint.x - this.options.pixelSize * Math.cos(headAngle2), tipPoint.y + this.options.pixelSize * Math.sin(headAngle2));\n\n        return [map.unproject(arrowHead1), dirPoint.latLng, map.unproject(arrowHead2)];\n    }\n});\n\nL$1.Symbol.arrowHead = function (options) {\n    return new L$1.Symbol.ArrowHead(options);\n};\n\nL$1.Symbol.Marker = L$1.Class.extend({\n    options: {\n        markerOptions: {},\n        rotate: false\n    },\n\n    initialize: function initialize(options) {\n        L$1.Util.setOptions(this, options);\n        this.options.markerOptions.clickable = false;\n        this.options.markerOptions.draggable = false;\n    },\n\n    buildSymbol: function buildSymbol(directionPoint, latLngs, map, index, total) {\n        if (this.options.rotate) {\n            this.options.markerOptions.rotationAngle = directionPoint.heading + (this.options.angleCorrection || 0);\n        }\n        return L$1.marker(directionPoint.latLng, this.options.markerOptions);\n    }\n});\n\nL$1.Symbol.marker = function (options) {\n    return new L$1.Symbol.Marker(options);\n};\n\nvar isCoord = function isCoord(c) {\n    return c instanceof L$1.LatLng || Array.isArray(c) && c.length === 2 && typeof c[0] === 'number';\n};\n\nvar isCoordArray = function isCoordArray(ll) {\n    return Array.isArray(ll) && isCoord(ll[0]);\n};\n\nL$1.PolylineDecorator = L$1.FeatureGroup.extend({\n    options: {\n        patterns: []\n    },\n\n    initialize: function initialize(paths, options) {\n        L$1.FeatureGroup.prototype.initialize.call(this);\n        L$1.Util.setOptions(this, options);\n        this._map = null;\n        this._paths = this._initPaths(paths);\n        this._bounds = this._initBounds();\n        this._patterns = this._initPatterns(this.options.patterns);\n    },\n\n    /**\n    * Deals with all the different cases. input can be one of these types:\n    * array of LatLng, array of 2-number arrays, Polyline, Polygon,\n    * array of one of the previous.\n    */\n    _initPaths: function _initPaths(input, isPolygon) {\n        var _this = this;\n\n        if (isCoordArray(input)) {\n            // Leaflet Polygons don't need the first point to be repeated, but we do\n            var coords = isPolygon ? input.concat([input[0]]) : input;\n            return [coords];\n        }\n        if (input instanceof L$1.Polyline) {\n            // we need some recursivity to support multi-poly*\n            return this._initPaths(input.getLatLngs(), input instanceof L$1.Polygon);\n        }\n        if (Array.isArray(input)) {\n            // flatten everything, we just need coordinate lists to apply patterns\n            return input.reduce(function (flatArray, p) {\n                return flatArray.concat(_this._initPaths(p, isPolygon));\n            }, []);\n        }\n        return [];\n    },\n\n    // parse pattern definitions and precompute some values\n    _initPatterns: function _initPatterns(patternDefs) {\n        return patternDefs.map(this._parsePatternDef);\n    },\n\n    /**\n    * Changes the patterns used by this decorator\n    * and redraws the new one.\n    */\n    setPatterns: function setPatterns(patterns) {\n        this.options.patterns = patterns;\n        this._patterns = this._initPatterns(this.options.patterns);\n        this.redraw();\n    },\n\n    /**\n    * Changes the patterns used by this decorator\n    * and redraws the new one.\n    */\n    setPaths: function setPaths(paths) {\n        this._paths = this._initPaths(paths);\n        this._bounds = this._initBounds();\n        this.redraw();\n    },\n\n    /**\n    * Parse the pattern definition\n    */\n    _parsePatternDef: function _parsePatternDef(patternDef, latLngs) {\n        return {\n            symbolFactory: patternDef.symbol,\n            // Parse offset and repeat values, managing the two cases:\n            // absolute (in pixels) or relative (in percentage of the polyline length)\n            offset: parseRelativeOrAbsoluteValue(patternDef.offset),\n            endOffset: parseRelativeOrAbsoluteValue(patternDef.endOffset),\n            repeat: parseRelativeOrAbsoluteValue(patternDef.repeat)\n        };\n    },\n\n    onAdd: function onAdd(map) {\n        this._map = map;\n        this._draw();\n        this._map.on('moveend', this.redraw, this);\n    },\n\n    onRemove: function onRemove(map) {\n        this._map.off('moveend', this.redraw, this);\n        this._map = null;\n        L$1.FeatureGroup.prototype.onRemove.call(this, map);\n    },\n\n    /**\n    * As real pattern bounds depends on map zoom and bounds,\n    * we just compute the total bounds of all paths decorated by this instance.\n    */\n    _initBounds: function _initBounds() {\n        var allPathCoords = this._paths.reduce(function (acc, path) {\n            return acc.concat(path);\n        }, []);\n        return L$1.latLngBounds(allPathCoords);\n    },\n\n    getBounds: function getBounds() {\n        return this._bounds;\n    },\n\n    /**\n    * Returns an array of ILayers object\n    */\n    _buildSymbols: function _buildSymbols(latLngs, symbolFactory, directionPoints) {\n        var _this2 = this;\n\n        return directionPoints.map(function (directionPoint, i) {\n            return symbolFactory.buildSymbol(directionPoint, latLngs, _this2._map, i, directionPoints.length);\n        });\n    },\n\n    /**\n    * Compute pairs of LatLng and heading angle,\n    * that define positions and directions of the symbols on the path\n    */\n    _getDirectionPoints: function _getDirectionPoints(latLngs, pattern) {\n        var _this3 = this;\n\n        if (latLngs.length < 2) {\n            return [];\n        }\n        var pathAsPoints = latLngs.map(function (latLng) {\n            return _this3._map.project(latLng);\n        });\n        return projectPatternOnPointPath(pathAsPoints, pattern).map(function (point) {\n            return {\n                latLng: _this3._map.unproject(L$1.point(point.pt)),\n                heading: point.heading\n            };\n        });\n    },\n\n    redraw: function redraw() {\n        if (!this._map) {\n            return;\n        }\n        this.clearLayers();\n        this._draw();\n    },\n\n    /**\n    * Returns all symbols for a given pattern as an array of FeatureGroup\n    */\n    _getPatternLayers: function _getPatternLayers(pattern) {\n        var _this4 = this;\n\n        var mapBounds = this._map.getBounds().pad(0.1);\n        return this._paths.map(function (path) {\n            var directionPoints = _this4._getDirectionPoints(path, pattern)\n            // filter out invisible points\n            .filter(function (point) {\n                return mapBounds.contains(point.latLng);\n            });\n            return L$1.featureGroup(_this4._buildSymbols(path, pattern.symbolFactory, directionPoints));\n        });\n    },\n\n    /**\n    * Draw all patterns\n    */\n    _draw: function _draw() {\n        var _this5 = this;\n\n        this._patterns.map(function (pattern) {\n            return _this5._getPatternLayers(pattern);\n        }).forEach(function (layers) {\n            _this5.addLayer(L$1.featureGroup(layers));\n        });\n    }\n});\n/*\n * Allows compact syntax to be used\n */\nL$1.polylineDecorator = function (paths, options) {\n    return new L$1.PolylineDecorator(paths, options);\n};\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGVhZmxldC1wb2x5bGluZWRlY29yYXRvci9kaXN0L2xlYWZsZXQucG9seWxpbmVEZWNvcmF0b3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxDQUFDLEtBQTRELFdBQVcsbUJBQU8sQ0FBQyxpRUFBUztBQUN6RixDQUFDLENBQ21CO0FBQ3BCLENBQUMseUJBQXlCOztBQUUxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsNEJBQTRCO0FBQ2xFLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXDQxbVxcRGVza3RvcFxcTUlHTkVUVlVfVUlcXG5vZGVfbW9kdWxlc1xcbGVhZmxldC1wb2x5bGluZWRlY29yYXRvclxcZGlzdFxcbGVhZmxldC5wb2x5bGluZURlY29yYXRvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KHJlcXVpcmUoJ2xlYWZsZXQnKSkgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydsZWFmbGV0J10sIGZhY3RvcnkpIDpcblx0KGZhY3RvcnkoZ2xvYmFsLkwpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChMJDEpIHsgJ3VzZSBzdHJpY3QnO1xuXG5MJDEgPSBMJDEgJiYgTCQxLmhhc093blByb3BlcnR5KCdkZWZhdWx0JykgPyBMJDFbJ2RlZmF1bHQnXSA6IEwkMTtcblxuLy8gZnVuY3Rpb25hbCByZS1pbXBsIG9mIEwuUG9pbnQuZGlzdGFuY2VUbyxcbi8vIHdpdGggbm8gZGVwZW5kZW5jeSBvbiBMZWFmbGV0IGZvciBlYXNpZXIgdGVzdGluZ1xuZnVuY3Rpb24gcG9pbnREaXN0YW5jZShwdEEsIHB0Qikge1xuICAgIHZhciB4ID0gcHRCLnggLSBwdEEueDtcbiAgICB2YXIgeSA9IHB0Qi55IC0gcHRBLnk7XG4gICAgcmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbn1cblxudmFyIGNvbXB1dGVTZWdtZW50SGVhZGluZyA9IGZ1bmN0aW9uIGNvbXB1dGVTZWdtZW50SGVhZGluZyhhLCBiKSB7XG4gICAgcmV0dXJuIChNYXRoLmF0YW4yKGIueSAtIGEueSwgYi54IC0gYS54KSAqIDE4MCAvIE1hdGguUEkgKyA5MCArIDM2MCkgJSAzNjA7XG59O1xuXG52YXIgYXNSYXRpb1RvUGF0aExlbmd0aCA9IGZ1bmN0aW9uIGFzUmF0aW9Ub1BhdGhMZW5ndGgoX3JlZiwgdG90YWxQYXRoTGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gX3JlZi52YWx1ZSxcbiAgICAgICAgaXNJblBpeGVscyA9IF9yZWYuaXNJblBpeGVscztcbiAgICByZXR1cm4gaXNJblBpeGVscyA/IHZhbHVlIC8gdG90YWxQYXRoTGVuZ3RoIDogdmFsdWU7XG59O1xuXG5mdW5jdGlvbiBwYXJzZVJlbGF0aXZlT3JBYnNvbHV0ZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUuaW5kZXhPZignJScpICE9PSAtMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHBhcnNlRmxvYXQodmFsdWUpIC8gMTAwLFxuICAgICAgICAgICAgaXNJblBpeGVsczogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmFyIHBhcnNlZFZhbHVlID0gdmFsdWUgPyBwYXJzZUZsb2F0KHZhbHVlKSA6IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHBhcnNlZFZhbHVlLFxuICAgICAgICBpc0luUGl4ZWxzOiBwYXJzZWRWYWx1ZSA+IDBcbiAgICB9O1xufVxuXG52YXIgcG9pbnRzRXF1YWwgPSBmdW5jdGlvbiBwb2ludHNFcXVhbChhLCBiKSB7XG4gICAgcmV0dXJuIGEueCA9PT0gYi54ICYmIGEueSA9PT0gYi55O1xufTtcblxuZnVuY3Rpb24gcG9pbnRzVG9TZWdtZW50cyhwdHMpIHtcbiAgICByZXR1cm4gcHRzLnJlZHVjZShmdW5jdGlvbiAoc2VnbWVudHMsIGIsIGlkeCwgcG9pbnRzKSB7XG4gICAgICAgIC8vIHRoaXMgdGVzdCBza2lwcyBzYW1lIGFkamFjZW50IHBvaW50c1xuICAgICAgICBpZiAoaWR4ID4gMCAmJiAhcG9pbnRzRXF1YWwoYiwgcG9pbnRzW2lkeCAtIDFdKSkge1xuICAgICAgICAgICAgdmFyIGEgPSBwb2ludHNbaWR4IC0gMV07XG4gICAgICAgICAgICB2YXIgZGlzdEEgPSBzZWdtZW50cy5sZW5ndGggPiAwID8gc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV0uZGlzdEIgOiAwO1xuICAgICAgICAgICAgdmFyIGRpc3RBQiA9IHBvaW50RGlzdGFuY2UoYSwgYik7XG4gICAgICAgICAgICBzZWdtZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBhOiBhLFxuICAgICAgICAgICAgICAgIGI6IGIsXG4gICAgICAgICAgICAgICAgZGlzdEE6IGRpc3RBLFxuICAgICAgICAgICAgICAgIGRpc3RCOiBkaXN0QSArIGRpc3RBQixcbiAgICAgICAgICAgICAgICBoZWFkaW5nOiBjb21wdXRlU2VnbWVudEhlYWRpbmcoYSwgYilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWdtZW50cztcbiAgICB9LCBbXSk7XG59XG5cbmZ1bmN0aW9uIHByb2plY3RQYXR0ZXJuT25Qb2ludFBhdGgocHRzLCBwYXR0ZXJuKSB7XG4gICAgLy8gMS4gc3BsaXQgdGhlIHBhdGggaW50byBzZWdtZW50IGluZm9zXG4gICAgdmFyIHNlZ21lbnRzID0gcG9pbnRzVG9TZWdtZW50cyhwdHMpO1xuICAgIHZhciBuYlNlZ21lbnRzID0gc2VnbWVudHMubGVuZ3RoO1xuICAgIGlmIChuYlNlZ21lbnRzID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICB2YXIgdG90YWxQYXRoTGVuZ3RoID0gc2VnbWVudHNbbmJTZWdtZW50cyAtIDFdLmRpc3RCO1xuXG4gICAgdmFyIG9mZnNldCA9IGFzUmF0aW9Ub1BhdGhMZW5ndGgocGF0dGVybi5vZmZzZXQsIHRvdGFsUGF0aExlbmd0aCk7XG4gICAgdmFyIGVuZE9mZnNldCA9IGFzUmF0aW9Ub1BhdGhMZW5ndGgocGF0dGVybi5lbmRPZmZzZXQsIHRvdGFsUGF0aExlbmd0aCk7XG4gICAgdmFyIHJlcGVhdCA9IGFzUmF0aW9Ub1BhdGhMZW5ndGgocGF0dGVybi5yZXBlYXQsIHRvdGFsUGF0aExlbmd0aCk7XG5cbiAgICB2YXIgcmVwZWF0SW50ZXJ2YWxQaXhlbHMgPSB0b3RhbFBhdGhMZW5ndGggKiByZXBlYXQ7XG4gICAgdmFyIHN0YXJ0T2Zmc2V0UGl4ZWxzID0gb2Zmc2V0ID4gMCA/IHRvdGFsUGF0aExlbmd0aCAqIG9mZnNldCA6IDA7XG4gICAgdmFyIGVuZE9mZnNldFBpeGVscyA9IGVuZE9mZnNldCA+IDAgPyB0b3RhbFBhdGhMZW5ndGggKiBlbmRPZmZzZXQgOiAwO1xuXG4gICAgLy8gMi4gZ2VuZXJhdGUgdGhlIHBvc2l0aW9ucyBvZiB0aGUgcGF0dGVybiBhcyBvZmZzZXRzIGZyb20gdGhlIHBhdGggc3RhcnRcbiAgICB2YXIgcG9zaXRpb25PZmZzZXRzID0gW107XG4gICAgdmFyIHBvc2l0aW9uT2Zmc2V0ID0gc3RhcnRPZmZzZXRQaXhlbHM7XG4gICAgZG8ge1xuICAgICAgICBwb3NpdGlvbk9mZnNldHMucHVzaChwb3NpdGlvbk9mZnNldCk7XG4gICAgICAgIHBvc2l0aW9uT2Zmc2V0ICs9IHJlcGVhdEludGVydmFsUGl4ZWxzO1xuICAgIH0gd2hpbGUgKHJlcGVhdEludGVydmFsUGl4ZWxzID4gMCAmJiBwb3NpdGlvbk9mZnNldCA8IHRvdGFsUGF0aExlbmd0aCAtIGVuZE9mZnNldFBpeGVscyk7XG5cbiAgICAvLyAzLiBwcm9qZWN0cyBvZmZzZXRzIHRvIHNlZ21lbnRzXG4gICAgdmFyIHNlZ21lbnRJbmRleCA9IDA7XG4gICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50c1swXTtcbiAgICByZXR1cm4gcG9zaXRpb25PZmZzZXRzLm1hcChmdW5jdGlvbiAocG9zaXRpb25PZmZzZXQpIHtcbiAgICAgICAgLy8gZmluZCB0aGUgc2VnbWVudCBtYXRjaGluZyB0aGUgb2Zmc2V0LFxuICAgICAgICAvLyBzdGFydGluZyBmcm9tIHRoZSBwcmV2aW91cyBvbmUgYXMgb2Zmc2V0cyBhcmUgb3JkZXJlZFxuICAgICAgICB3aGlsZSAocG9zaXRpb25PZmZzZXQgPiBzZWdtZW50LmRpc3RCICYmIHNlZ21lbnRJbmRleCA8IG5iU2VnbWVudHMgLSAxKSB7XG4gICAgICAgICAgICBzZWdtZW50SW5kZXgrKztcbiAgICAgICAgICAgIHNlZ21lbnQgPSBzZWdtZW50c1tzZWdtZW50SW5kZXhdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlZ21lbnRSYXRpbyA9IChwb3NpdGlvbk9mZnNldCAtIHNlZ21lbnQuZGlzdEEpIC8gKHNlZ21lbnQuZGlzdEIgLSBzZWdtZW50LmRpc3RBKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHB0OiBpbnRlcnBvbGF0ZUJldHdlZW5Qb2ludHMoc2VnbWVudC5hLCBzZWdtZW50LmIsIHNlZ21lbnRSYXRpbyksXG4gICAgICAgICAgICBoZWFkaW5nOiBzZWdtZW50LmhlYWRpbmdcbiAgICAgICAgfTtcbiAgICB9KTtcbn1cblxuLyoqXG4qIEZpbmRzIHRoZSBwb2ludCB3aGljaCBsaWVzIG9uIHRoZSBzZWdtZW50IGRlZmluZWQgYnkgcG9pbnRzIEEgYW5kIEIsXG4qIGF0IHRoZSBnaXZlbiByYXRpbyBvZiB0aGUgZGlzdGFuY2UgZnJvbSBBIHRvIEIsIGJ5IGxpbmVhciBpbnRlcnBvbGF0aW9uLlxuKi9cbmZ1bmN0aW9uIGludGVycG9sYXRlQmV0d2VlblBvaW50cyhwdEEsIHB0QiwgcmF0aW8pIHtcbiAgICBpZiAocHRCLnggIT09IHB0QS54KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiBwdEEueCArIHJhdGlvICogKHB0Qi54IC0gcHRBLngpLFxuICAgICAgICAgICAgeTogcHRBLnkgKyByYXRpbyAqIChwdEIueSAtIHB0QS55KVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBzcGVjaWFsIGNhc2Ugd2hlcmUgcG9pbnRzIGxpZSBvbiB0aGUgc2FtZSB2ZXJ0aWNhbCBheGlzXG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogcHRBLngsXG4gICAgICAgIHk6IHB0QS55ICsgKHB0Qi55IC0gcHRBLnkpICogcmF0aW9cbiAgICB9O1xufVxuXG4oZnVuY3Rpb24oKSB7XHJcbiAgICAvLyBzYXZlIHRoZXNlIG9yaWdpbmFsIG1ldGhvZHMgYmVmb3JlIHRoZXkgYXJlIG92ZXJ3cml0dGVuXHJcbiAgICB2YXIgcHJvdG9faW5pdEljb24gPSBMLk1hcmtlci5wcm90b3R5cGUuX2luaXRJY29uO1xyXG4gICAgdmFyIHByb3RvX3NldFBvcyA9IEwuTWFya2VyLnByb3RvdHlwZS5fc2V0UG9zO1xyXG5cclxuICAgIHZhciBvbGRJRSA9IChMLkRvbVV0aWwuVFJBTlNGT1JNID09PSAnbXNUcmFuc2Zvcm0nKTtcclxuXHJcbiAgICBMLk1hcmtlci5hZGRJbml0SG9vayhmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGljb25PcHRpb25zID0gdGhpcy5vcHRpb25zLmljb24gJiYgdGhpcy5vcHRpb25zLmljb24ub3B0aW9ucztcclxuICAgICAgICB2YXIgaWNvbkFuY2hvciA9IGljb25PcHRpb25zICYmIHRoaXMub3B0aW9ucy5pY29uLm9wdGlvbnMuaWNvbkFuY2hvcjtcclxuICAgICAgICBpZiAoaWNvbkFuY2hvcikge1xyXG4gICAgICAgICAgICBpY29uQW5jaG9yID0gKGljb25BbmNob3JbMF0gKyAncHggJyArIGljb25BbmNob3JbMV0gKyAncHgnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5vcHRpb25zLnJvdGF0aW9uT3JpZ2luID0gdGhpcy5vcHRpb25zLnJvdGF0aW9uT3JpZ2luIHx8IGljb25BbmNob3IgfHwgJ2NlbnRlciBib3R0b20nIDtcclxuICAgICAgICB0aGlzLm9wdGlvbnMucm90YXRpb25BbmdsZSA9IHRoaXMub3B0aW9ucy5yb3RhdGlvbkFuZ2xlIHx8IDA7XHJcblxyXG4gICAgICAgIC8vIEVuc3VyZSBtYXJrZXIga2VlcHMgcm90YXRlZCBkdXJpbmcgZHJhZ2dpbmdcclxuICAgICAgICB0aGlzLm9uKCdkcmFnJywgZnVuY3Rpb24oZSkgeyBlLnRhcmdldC5fYXBwbHlSb3RhdGlvbigpOyB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIEwuTWFya2VyLmluY2x1ZGUoe1xyXG4gICAgICAgIF9pbml0SWNvbjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHByb3RvX2luaXRJY29uLmNhbGwodGhpcyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX3NldFBvczogZnVuY3Rpb24gKHBvcykge1xyXG4gICAgICAgICAgICBwcm90b19zZXRQb3MuY2FsbCh0aGlzLCBwb3MpO1xyXG4gICAgICAgICAgICB0aGlzLl9hcHBseVJvdGF0aW9uKCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2FwcGx5Um90YXRpb246IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLnJvdGF0aW9uQW5nbGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ljb24uc3R5bGVbTC5Eb21VdGlsLlRSQU5TRk9STSsnT3JpZ2luJ10gPSB0aGlzLm9wdGlvbnMucm90YXRpb25PcmlnaW47XHJcblxyXG4gICAgICAgICAgICAgICAgaWYob2xkSUUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBmb3IgSUUgOSwgdXNlIHRoZSAyRCByb3RhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ljb24uc3R5bGVbTC5Eb21VdGlsLlRSQU5TRk9STV0gPSAncm90YXRlKCcgKyB0aGlzLm9wdGlvbnMucm90YXRpb25BbmdsZSArICdkZWcpJztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yIG1vZGVybiBicm93c2VycywgcHJlZmVyIHRoZSAzRCBhY2NlbGVyYXRlZCB2ZXJzaW9uXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faWNvbi5zdHlsZVtMLkRvbVV0aWwuVFJBTlNGT1JNXSArPSAnIHJvdGF0ZVooJyArIHRoaXMub3B0aW9ucy5yb3RhdGlvbkFuZ2xlICsgJ2RlZyknO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0Um90YXRpb25BbmdsZTogZnVuY3Rpb24oYW5nbGUpIHtcclxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnJvdGF0aW9uQW5nbGUgPSBhbmdsZTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0Um90YXRpb25PcmlnaW46IGZ1bmN0aW9uKG9yaWdpbikge1xyXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMucm90YXRpb25PcmlnaW4gPSBvcmlnaW47XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59KSgpO1xuXG5MJDEuU3ltYm9sID0gTCQxLlN5bWJvbCB8fCB7fTtcblxuLyoqXG4qIEEgc2ltcGxlIGRhc2ggc3ltYm9sLCBkcmF3biBhcyBhIFBvbHlsaW5lLlxuKiBDYW4gYWxzbyBiZSB1c2VkIGZvciBkb3RzLCBpZiAncGl4ZWxTaXplJyBvcHRpb24gaXMgZ2l2ZW4gdGhlIDAgdmFsdWUuXG4qL1xuTCQxLlN5bWJvbC5EYXNoID0gTCQxLkNsYXNzLmV4dGVuZCh7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBwaXhlbFNpemU6IDEwLFxuICAgICAgICBwYXRoT3B0aW9uczoge31cbiAgICB9LFxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZShvcHRpb25zKSB7XG4gICAgICAgIEwkMS5VdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMub3B0aW9ucy5wYXRoT3B0aW9ucy5jbGlja2FibGUgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgYnVpbGRTeW1ib2w6IGZ1bmN0aW9uIGJ1aWxkU3ltYm9sKGRpclBvaW50LCBsYXRMbmdzLCBtYXAsIGluZGV4LCB0b3RhbCkge1xuICAgICAgICB2YXIgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgdmFyIGQyciA9IE1hdGguUEkgLyAxODA7XG5cbiAgICAgICAgLy8gZm9yIGEgZG90LCBub3RoaW5nIG1vcmUgdG8gY29tcHV0ZVxuICAgICAgICBpZiAob3B0cy5waXhlbFNpemUgPD0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIEwkMS5wb2x5bGluZShbZGlyUG9pbnQubGF0TG5nLCBkaXJQb2ludC5sYXRMbmddLCBvcHRzLnBhdGhPcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtaWRQb2ludCA9IG1hcC5wcm9qZWN0KGRpclBvaW50LmxhdExuZyk7XG4gICAgICAgIHZhciBhbmdsZSA9IC0oZGlyUG9pbnQuaGVhZGluZyAtIDkwKSAqIGQycjtcbiAgICAgICAgdmFyIGEgPSBMJDEucG9pbnQobWlkUG9pbnQueCArIG9wdHMucGl4ZWxTaXplICogTWF0aC5jb3MoYW5nbGUgKyBNYXRoLlBJKSAvIDIsIG1pZFBvaW50LnkgKyBvcHRzLnBpeGVsU2l6ZSAqIE1hdGguc2luKGFuZ2xlKSAvIDIpO1xuICAgICAgICAvLyBjb21wdXRlIHNlY29uZCBwb2ludCBieSBjZW50cmFsIHN5bW1ldHJ5IHRvIGF2b2lkIHVuZWNlc3NhcnkgY29zL3NpblxuICAgICAgICB2YXIgYiA9IG1pZFBvaW50LmFkZChtaWRQb2ludC5zdWJ0cmFjdChhKSk7XG4gICAgICAgIHJldHVybiBMJDEucG9seWxpbmUoW21hcC51bnByb2plY3QoYSksIG1hcC51bnByb2plY3QoYildLCBvcHRzLnBhdGhPcHRpb25zKTtcbiAgICB9XG59KTtcblxuTCQxLlN5bWJvbC5kYXNoID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IEwkMS5TeW1ib2wuRGFzaChvcHRpb25zKTtcbn07XG5cbkwkMS5TeW1ib2wuQXJyb3dIZWFkID0gTCQxLkNsYXNzLmV4dGVuZCh7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBwb2x5Z29uOiB0cnVlLFxuICAgICAgICBwaXhlbFNpemU6IDEwLFxuICAgICAgICBoZWFkQW5nbGU6IDYwLFxuICAgICAgICBwYXRoT3B0aW9uczoge1xuICAgICAgICAgICAgc3Ryb2tlOiBmYWxzZSxcbiAgICAgICAgICAgIHdlaWdodDogMlxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIGluaXRpYWxpemUob3B0aW9ucykge1xuICAgICAgICBMJDEuVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLm9wdGlvbnMucGF0aE9wdGlvbnMuY2xpY2thYmxlID0gZmFsc2U7XG4gICAgfSxcblxuICAgIGJ1aWxkU3ltYm9sOiBmdW5jdGlvbiBidWlsZFN5bWJvbChkaXJQb2ludCwgbGF0TG5ncywgbWFwLCBpbmRleCwgdG90YWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5wb2x5Z29uID8gTCQxLnBvbHlnb24odGhpcy5fYnVpbGRBcnJvd1BhdGgoZGlyUG9pbnQsIG1hcCksIHRoaXMub3B0aW9ucy5wYXRoT3B0aW9ucykgOiBMJDEucG9seWxpbmUodGhpcy5fYnVpbGRBcnJvd1BhdGgoZGlyUG9pbnQsIG1hcCksIHRoaXMub3B0aW9ucy5wYXRoT3B0aW9ucyk7XG4gICAgfSxcblxuICAgIF9idWlsZEFycm93UGF0aDogZnVuY3Rpb24gX2J1aWxkQXJyb3dQYXRoKGRpclBvaW50LCBtYXApIHtcbiAgICAgICAgdmFyIGQyciA9IE1hdGguUEkgLyAxODA7XG4gICAgICAgIHZhciB0aXBQb2ludCA9IG1hcC5wcm9qZWN0KGRpclBvaW50LmxhdExuZyk7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSAtKGRpclBvaW50LmhlYWRpbmcgLSA5MCkgKiBkMnI7XG4gICAgICAgIHZhciByYWRpYW5BcnJvd0FuZ2xlID0gdGhpcy5vcHRpb25zLmhlYWRBbmdsZSAvIDIgKiBkMnI7XG5cbiAgICAgICAgdmFyIGhlYWRBbmdsZTEgPSBkaXJlY3Rpb24gKyByYWRpYW5BcnJvd0FuZ2xlO1xuICAgICAgICB2YXIgaGVhZEFuZ2xlMiA9IGRpcmVjdGlvbiAtIHJhZGlhbkFycm93QW5nbGU7XG4gICAgICAgIHZhciBhcnJvd0hlYWQxID0gTCQxLnBvaW50KHRpcFBvaW50LnggLSB0aGlzLm9wdGlvbnMucGl4ZWxTaXplICogTWF0aC5jb3MoaGVhZEFuZ2xlMSksIHRpcFBvaW50LnkgKyB0aGlzLm9wdGlvbnMucGl4ZWxTaXplICogTWF0aC5zaW4oaGVhZEFuZ2xlMSkpO1xuICAgICAgICB2YXIgYXJyb3dIZWFkMiA9IEwkMS5wb2ludCh0aXBQb2ludC54IC0gdGhpcy5vcHRpb25zLnBpeGVsU2l6ZSAqIE1hdGguY29zKGhlYWRBbmdsZTIpLCB0aXBQb2ludC55ICsgdGhpcy5vcHRpb25zLnBpeGVsU2l6ZSAqIE1hdGguc2luKGhlYWRBbmdsZTIpKTtcblxuICAgICAgICByZXR1cm4gW21hcC51bnByb2plY3QoYXJyb3dIZWFkMSksIGRpclBvaW50LmxhdExuZywgbWFwLnVucHJvamVjdChhcnJvd0hlYWQyKV07XG4gICAgfVxufSk7XG5cbkwkMS5TeW1ib2wuYXJyb3dIZWFkID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IEwkMS5TeW1ib2wuQXJyb3dIZWFkKG9wdGlvbnMpO1xufTtcblxuTCQxLlN5bWJvbC5NYXJrZXIgPSBMJDEuQ2xhc3MuZXh0ZW5kKHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIG1hcmtlck9wdGlvbnM6IHt9LFxuICAgICAgICByb3RhdGU6IGZhbHNlXG4gICAgfSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIGluaXRpYWxpemUob3B0aW9ucykge1xuICAgICAgICBMJDEuVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLm9wdGlvbnMubWFya2VyT3B0aW9ucy5jbGlja2FibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vcHRpb25zLm1hcmtlck9wdGlvbnMuZHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgfSxcblxuICAgIGJ1aWxkU3ltYm9sOiBmdW5jdGlvbiBidWlsZFN5bWJvbChkaXJlY3Rpb25Qb2ludCwgbGF0TG5ncywgbWFwLCBpbmRleCwgdG90YWwpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yb3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5tYXJrZXJPcHRpb25zLnJvdGF0aW9uQW5nbGUgPSBkaXJlY3Rpb25Qb2ludC5oZWFkaW5nICsgKHRoaXMub3B0aW9ucy5hbmdsZUNvcnJlY3Rpb24gfHwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEwkMS5tYXJrZXIoZGlyZWN0aW9uUG9pbnQubGF0TG5nLCB0aGlzLm9wdGlvbnMubWFya2VyT3B0aW9ucyk7XG4gICAgfVxufSk7XG5cbkwkMS5TeW1ib2wubWFya2VyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IEwkMS5TeW1ib2wuTWFya2VyKG9wdGlvbnMpO1xufTtcblxudmFyIGlzQ29vcmQgPSBmdW5jdGlvbiBpc0Nvb3JkKGMpIHtcbiAgICByZXR1cm4gYyBpbnN0YW5jZW9mIEwkMS5MYXRMbmcgfHwgQXJyYXkuaXNBcnJheShjKSAmJiBjLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgY1swXSA9PT0gJ251bWJlcic7XG59O1xuXG52YXIgaXNDb29yZEFycmF5ID0gZnVuY3Rpb24gaXNDb29yZEFycmF5KGxsKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkobGwpICYmIGlzQ29vcmQobGxbMF0pO1xufTtcblxuTCQxLlBvbHlsaW5lRGVjb3JhdG9yID0gTCQxLkZlYXR1cmVHcm91cC5leHRlbmQoe1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgcGF0dGVybnM6IFtdXG4gICAgfSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIGluaXRpYWxpemUocGF0aHMsIG9wdGlvbnMpIHtcbiAgICAgICAgTCQxLkZlYXR1cmVHcm91cC5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMpO1xuICAgICAgICBMJDEuVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9tYXAgPSBudWxsO1xuICAgICAgICB0aGlzLl9wYXRocyA9IHRoaXMuX2luaXRQYXRocyhwYXRocyk7XG4gICAgICAgIHRoaXMuX2JvdW5kcyA9IHRoaXMuX2luaXRCb3VuZHMoKTtcbiAgICAgICAgdGhpcy5fcGF0dGVybnMgPSB0aGlzLl9pbml0UGF0dGVybnModGhpcy5vcHRpb25zLnBhdHRlcm5zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBEZWFscyB3aXRoIGFsbCB0aGUgZGlmZmVyZW50IGNhc2VzLiBpbnB1dCBjYW4gYmUgb25lIG9mIHRoZXNlIHR5cGVzOlxuICAgICogYXJyYXkgb2YgTGF0TG5nLCBhcnJheSBvZiAyLW51bWJlciBhcnJheXMsIFBvbHlsaW5lLCBQb2x5Z29uLFxuICAgICogYXJyYXkgb2Ygb25lIG9mIHRoZSBwcmV2aW91cy5cbiAgICAqL1xuICAgIF9pbml0UGF0aHM6IGZ1bmN0aW9uIF9pbml0UGF0aHMoaW5wdXQsIGlzUG9seWdvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIGlmIChpc0Nvb3JkQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICAvLyBMZWFmbGV0IFBvbHlnb25zIGRvbid0IG5lZWQgdGhlIGZpcnN0IHBvaW50IHRvIGJlIHJlcGVhdGVkLCBidXQgd2UgZG9cbiAgICAgICAgICAgIHZhciBjb29yZHMgPSBpc1BvbHlnb24gPyBpbnB1dC5jb25jYXQoW2lucHV0WzBdXSkgOiBpbnB1dDtcbiAgICAgICAgICAgIHJldHVybiBbY29vcmRzXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBMJDEuUG9seWxpbmUpIHtcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgc29tZSByZWN1cnNpdml0eSB0byBzdXBwb3J0IG11bHRpLXBvbHkqXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW5pdFBhdGhzKGlucHV0LmdldExhdExuZ3MoKSwgaW5wdXQgaW5zdGFuY2VvZiBMJDEuUG9seWdvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICAvLyBmbGF0dGVuIGV2ZXJ5dGhpbmcsIHdlIGp1c3QgbmVlZCBjb29yZGluYXRlIGxpc3RzIHRvIGFwcGx5IHBhdHRlcm5zXG4gICAgICAgICAgICByZXR1cm4gaW5wdXQucmVkdWNlKGZ1bmN0aW9uIChmbGF0QXJyYXksIHApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmxhdEFycmF5LmNvbmNhdChfdGhpcy5faW5pdFBhdGhzKHAsIGlzUG9seWdvbikpO1xuICAgICAgICAgICAgfSwgW10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9LFxuXG4gICAgLy8gcGFyc2UgcGF0dGVybiBkZWZpbml0aW9ucyBhbmQgcHJlY29tcHV0ZSBzb21lIHZhbHVlc1xuICAgIF9pbml0UGF0dGVybnM6IGZ1bmN0aW9uIF9pbml0UGF0dGVybnMocGF0dGVybkRlZnMpIHtcbiAgICAgICAgcmV0dXJuIHBhdHRlcm5EZWZzLm1hcCh0aGlzLl9wYXJzZVBhdHRlcm5EZWYpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIENoYW5nZXMgdGhlIHBhdHRlcm5zIHVzZWQgYnkgdGhpcyBkZWNvcmF0b3JcbiAgICAqIGFuZCByZWRyYXdzIHRoZSBuZXcgb25lLlxuICAgICovXG4gICAgc2V0UGF0dGVybnM6IGZ1bmN0aW9uIHNldFBhdHRlcm5zKHBhdHRlcm5zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5wYXR0ZXJucyA9IHBhdHRlcm5zO1xuICAgICAgICB0aGlzLl9wYXR0ZXJucyA9IHRoaXMuX2luaXRQYXR0ZXJucyh0aGlzLm9wdGlvbnMucGF0dGVybnMpO1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIENoYW5nZXMgdGhlIHBhdHRlcm5zIHVzZWQgYnkgdGhpcyBkZWNvcmF0b3JcbiAgICAqIGFuZCByZWRyYXdzIHRoZSBuZXcgb25lLlxuICAgICovXG4gICAgc2V0UGF0aHM6IGZ1bmN0aW9uIHNldFBhdGhzKHBhdGhzKSB7XG4gICAgICAgIHRoaXMuX3BhdGhzID0gdGhpcy5faW5pdFBhdGhzKHBhdGhzKTtcbiAgICAgICAgdGhpcy5fYm91bmRzID0gdGhpcy5faW5pdEJvdW5kcygpO1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIFBhcnNlIHRoZSBwYXR0ZXJuIGRlZmluaXRpb25cbiAgICAqL1xuICAgIF9wYXJzZVBhdHRlcm5EZWY6IGZ1bmN0aW9uIF9wYXJzZVBhdHRlcm5EZWYocGF0dGVybkRlZiwgbGF0TG5ncykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3ltYm9sRmFjdG9yeTogcGF0dGVybkRlZi5zeW1ib2wsXG4gICAgICAgICAgICAvLyBQYXJzZSBvZmZzZXQgYW5kIHJlcGVhdCB2YWx1ZXMsIG1hbmFnaW5nIHRoZSB0d28gY2FzZXM6XG4gICAgICAgICAgICAvLyBhYnNvbHV0ZSAoaW4gcGl4ZWxzKSBvciByZWxhdGl2ZSAoaW4gcGVyY2VudGFnZSBvZiB0aGUgcG9seWxpbmUgbGVuZ3RoKVxuICAgICAgICAgICAgb2Zmc2V0OiBwYXJzZVJlbGF0aXZlT3JBYnNvbHV0ZVZhbHVlKHBhdHRlcm5EZWYub2Zmc2V0KSxcbiAgICAgICAgICAgIGVuZE9mZnNldDogcGFyc2VSZWxhdGl2ZU9yQWJzb2x1dGVWYWx1ZShwYXR0ZXJuRGVmLmVuZE9mZnNldCksXG4gICAgICAgICAgICByZXBlYXQ6IHBhcnNlUmVsYXRpdmVPckFic29sdXRlVmFsdWUocGF0dGVybkRlZi5yZXBlYXQpXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIG9uQWRkOiBmdW5jdGlvbiBvbkFkZChtYXApIHtcbiAgICAgICAgdGhpcy5fbWFwID0gbWFwO1xuICAgICAgICB0aGlzLl9kcmF3KCk7XG4gICAgICAgIHRoaXMuX21hcC5vbignbW92ZWVuZCcsIHRoaXMucmVkcmF3LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgb25SZW1vdmU6IGZ1bmN0aW9uIG9uUmVtb3ZlKG1hcCkge1xuICAgICAgICB0aGlzLl9tYXAub2ZmKCdtb3ZlZW5kJywgdGhpcy5yZWRyYXcsIHRoaXMpO1xuICAgICAgICB0aGlzLl9tYXAgPSBudWxsO1xuICAgICAgICBMJDEuRmVhdHVyZUdyb3VwLnByb3RvdHlwZS5vblJlbW92ZS5jYWxsKHRoaXMsIG1hcCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICogQXMgcmVhbCBwYXR0ZXJuIGJvdW5kcyBkZXBlbmRzIG9uIG1hcCB6b29tIGFuZCBib3VuZHMsXG4gICAgKiB3ZSBqdXN0IGNvbXB1dGUgdGhlIHRvdGFsIGJvdW5kcyBvZiBhbGwgcGF0aHMgZGVjb3JhdGVkIGJ5IHRoaXMgaW5zdGFuY2UuXG4gICAgKi9cbiAgICBfaW5pdEJvdW5kczogZnVuY3Rpb24gX2luaXRCb3VuZHMoKSB7XG4gICAgICAgIHZhciBhbGxQYXRoQ29vcmRzID0gdGhpcy5fcGF0aHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBhY2MuY29uY2F0KHBhdGgpO1xuICAgICAgICB9LCBbXSk7XG4gICAgICAgIHJldHVybiBMJDEubGF0TG5nQm91bmRzKGFsbFBhdGhDb29yZHMpO1xuICAgIH0sXG5cbiAgICBnZXRCb3VuZHM6IGZ1bmN0aW9uIGdldEJvdW5kcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JvdW5kcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIElMYXllcnMgb2JqZWN0XG4gICAgKi9cbiAgICBfYnVpbGRTeW1ib2xzOiBmdW5jdGlvbiBfYnVpbGRTeW1ib2xzKGxhdExuZ3MsIHN5bWJvbEZhY3RvcnksIGRpcmVjdGlvblBvaW50cykge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICByZXR1cm4gZGlyZWN0aW9uUG9pbnRzLm1hcChmdW5jdGlvbiAoZGlyZWN0aW9uUG9pbnQsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBzeW1ib2xGYWN0b3J5LmJ1aWxkU3ltYm9sKGRpcmVjdGlvblBvaW50LCBsYXRMbmdzLCBfdGhpczIuX21hcCwgaSwgZGlyZWN0aW9uUG9pbnRzLmxlbmd0aCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIENvbXB1dGUgcGFpcnMgb2YgTGF0TG5nIGFuZCBoZWFkaW5nIGFuZ2xlLFxuICAgICogdGhhdCBkZWZpbmUgcG9zaXRpb25zIGFuZCBkaXJlY3Rpb25zIG9mIHRoZSBzeW1ib2xzIG9uIHRoZSBwYXRoXG4gICAgKi9cbiAgICBfZ2V0RGlyZWN0aW9uUG9pbnRzOiBmdW5jdGlvbiBfZ2V0RGlyZWN0aW9uUG9pbnRzKGxhdExuZ3MsIHBhdHRlcm4pIHtcbiAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKGxhdExuZ3MubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXRoQXNQb2ludHMgPSBsYXRMbmdzLm1hcChmdW5jdGlvbiAobGF0TG5nKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMzLl9tYXAucHJvamVjdChsYXRMbmcpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHByb2plY3RQYXR0ZXJuT25Qb2ludFBhdGgocGF0aEFzUG9pbnRzLCBwYXR0ZXJuKS5tYXAoZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGxhdExuZzogX3RoaXMzLl9tYXAudW5wcm9qZWN0KEwkMS5wb2ludChwb2ludC5wdCkpLFxuICAgICAgICAgICAgICAgIGhlYWRpbmc6IHBvaW50LmhlYWRpbmdcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICByZWRyYXc6IGZ1bmN0aW9uIHJlZHJhdygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9tYXApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsZWFyTGF5ZXJzKCk7XG4gICAgICAgIHRoaXMuX2RyYXcoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBSZXR1cm5zIGFsbCBzeW1ib2xzIGZvciBhIGdpdmVuIHBhdHRlcm4gYXMgYW4gYXJyYXkgb2YgRmVhdHVyZUdyb3VwXG4gICAgKi9cbiAgICBfZ2V0UGF0dGVybkxheWVyczogZnVuY3Rpb24gX2dldFBhdHRlcm5MYXllcnMocGF0dGVybikge1xuICAgICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgICB2YXIgbWFwQm91bmRzID0gdGhpcy5fbWFwLmdldEJvdW5kcygpLnBhZCgwLjEpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcGF0aHMubWFwKGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgICAgICB2YXIgZGlyZWN0aW9uUG9pbnRzID0gX3RoaXM0Ll9nZXREaXJlY3Rpb25Qb2ludHMocGF0aCwgcGF0dGVybilcbiAgICAgICAgICAgIC8vIGZpbHRlciBvdXQgaW52aXNpYmxlIHBvaW50c1xuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFwQm91bmRzLmNvbnRhaW5zKHBvaW50LmxhdExuZyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBMJDEuZmVhdHVyZUdyb3VwKF90aGlzNC5fYnVpbGRTeW1ib2xzKHBhdGgsIHBhdHRlcm4uc3ltYm9sRmFjdG9yeSwgZGlyZWN0aW9uUG9pbnRzKSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIERyYXcgYWxsIHBhdHRlcm5zXG4gICAgKi9cbiAgICBfZHJhdzogZnVuY3Rpb24gX2RyYXcoKSB7XG4gICAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuX3BhdHRlcm5zLm1hcChmdW5jdGlvbiAocGF0dGVybikge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzNS5fZ2V0UGF0dGVybkxheWVycyhwYXR0ZXJuKTtcbiAgICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbiAobGF5ZXJzKSB7XG4gICAgICAgICAgICBfdGhpczUuYWRkTGF5ZXIoTCQxLmZlYXR1cmVHcm91cChsYXllcnMpKTtcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG4vKlxuICogQWxsb3dzIGNvbXBhY3Qgc3ludGF4IHRvIGJlIHVzZWRcbiAqL1xuTCQxLnBvbHlsaW5lRGVjb3JhdG9yID0gZnVuY3Rpb24gKHBhdGhzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBMJDEuUG9seWxpbmVEZWNvcmF0b3IocGF0aHMsIG9wdGlvbnMpO1xufTtcblxufSkpKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/leaflet-polylinedecorator/dist/leaflet.polylineDecorator.js\n");

/***/ })

};
;